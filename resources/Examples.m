(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



1


Needs["JLink`"]


ReinstallJava[CommandLine -> "/Library/Java/Home/bin/java",JVMArguments->"-Xmx1000m -Xms1000m -Djava.library.path=/usr/local/lib/ -classpath \"/Work/library/clojure-1.2.0/clojure.jar:/Work/library/clojure-1.2.0/clojure-contrib-1.2.0.jar:/Applications/Mathematica.app/SystemFiles/Links/JLink/JLink.jar\""]


LoadJavaClass/@{"clojure.lang.Compiler","clojure.lang.RT","java.io.StringReader"}


load[str_]:=(
Compiler`load[JavaNew["java.io.StringReader",
str]])


load["(ns user) (defn part [a b] (.part a b))"]


load["(ns user) (defn head [a] (.head a))"];


load["(ns user) (defn length [a] (.length a))"];


load["(ns user) (def jlink-object-handler (.getObjectHandler (com.wolfram.jlink.Install/getStdLink)))"]


load["(ns user) (use '[clojure.contrib.string :only [replace-str]]) (defn to-clojure-symbol [expr] 
				(let [sname (.asString expr)] 
					(cond 
						(= sname \"True\") true
						(= sname \"False\") false
						(= sname \"Null\") nil
						(= sname \"nil\") nil
						(= sname \"Equal\") '=
						(= sname \"SameQ\") '=
						(= sname \"Plus\") '+
						(= sname \"Times\") '*
						(= sname \"Division\") '/
						(= sname \"Rational\") '/
						(= sname \"Greater\") '>
						(= sname \"GreaterEqual\") '>=
						(= sname \"Less\") '<
						(= sname \"LessEqual\") '<=
						(= sname \"Unequal\") 'not=
						(re-matches #\"JLink`Object.*\" sname) (.getObject jlink-object-handler sname)
						(= (subs sname 0 1) \"\[EmptyVerySmallSquare]\") (keyword (replace-str \"\[LongDash]\" \"_\" (replace-str \"\[Dash]\" \"-\" (subs sname 1 (count sname)))))
						true (symbol (replace-str \"\[LongDash]\" \"_\" (replace-str \"\[Dash]\" \"-\" (replace-str \"\[FilledVerySmallSquare]\" \".\" sname))))
					)
	))
"]


load["(ns user) (use '[clojure.contrib.string :only [replace-str]]) (defn to-s-expression [expr] 
	(let [conpart (fn [seq expr p] (conj seq (to-s-expression (part expr p))))] 
	(cond	
		(and (.atomQ expr) (not (.rationalQ expr))) 
			(cond 
				(.symbolQ expr) (to-clojure-symbol expr)
				(.integerQ expr) (.asInt expr)
				(.realQ expr) (.asDouble expr)
				(.stringQ expr) (.asString expr))
		(= (.asString (head expr)) \"List\") (reduce #(conpart %1 expr (+ %2 1)) [] (range (length expr)))
		(= (.asString (head expr)) \"HashMap\") (into {} (reduce #(conpart %1 expr (+ %2 1)) [] (range (length expr))))
		(= (.asString (head expr)) \"HashSet\") (into #{} (reduce #(conpart %1 expr (+ %2 1)) [] (range (length expr))))
		(= (.asString (head expr)) \"ClojureSymbol\") (symbol (.asString (part expr 1)))
		true (reverse (reduce #(conpart %1 expr (+ %2 1)) (conj '() (to-s-expression (head expr))) (range (length expr))))
	)))"]


load["(ns user) (use '[clojure.contrib.string :only [replace-str]]) (defn to-mathematica-symbol [expr] 
				(let [sname  (replace-str \"_\" \"\[LongDash]\" (replace-str \"-\" \"\[Dash]\" (replace-str \":\" \"\[EmptyVerySmallSquare]\" (replace-str \".\" \"\[FilledVerySmallSquare]\" (str expr)))))] 
					(cond
						(= sname \"+\") (com.wolfram.jlink.Expr. 4 \"Plus\") 
						(= sname \">\") (com.wolfram.jlink.Expr. 4 \"Greater\")
						(= sname \">=\") (com.wolfram.jlink.Expr. 4 \"GreaterEqual\")
						(= sname \"<\")  (com.wolfram.jlink.Expr. 4 \"Less\")
						(= sname \"<=\") (com.wolfram.jlink.Expr. 4 \"LessEqual\")
						(= sname \"=\") (com.wolfram.jlink.Expr. 4 \"Equal\")
						(= sname \"not=\") (com.wolfram.jlink.Expr. 4 \"Unequal\")
						(empty? (re-matches #\"(\\w|\[LongDash]|\[Dash]|\[FilledVerySmallSquare]|\[EmptyVerySmallSquare]|\\$)*\" sname)) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"ClojureSymbol\") (into-array com.wolfram.jlink.Expr [(com.wolfram.jlink.Expr. sname)]))
						true (com.wolfram.jlink.Expr. 4 sname)
					)
	))
    
"]


load["(ns user)(def java-object-map)"
]


load["(ns user)(use '[clojure.contrib.string :only [replace-str]]) (defn createExprSub [struct] 
					(cond
						(= struct true) (com.wolfram.jlink.Expr. 4 \"True\")
						(= struct false) (com.wolfram.jlink.Expr. 4 \"False\")
						(= struct nil) (com.wolfram.jlink.Expr. 4 \"Null\")
						(ratio? struct) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"Rational\") (into-array com.wolfram.jlink.Expr (map createExprSub [(numerator struct) (denominator struct)])))
						(keyword? struct) (to-mathematica-symbol struct)
						(symbol? struct) (to-mathematica-symbol struct)
						(integer? struct) (com.wolfram.jlink.Expr.  1 (str struct))
						(float? struct) (com.wolfram.jlink.Expr.  2 (str struct))
						(string? struct) (com.wolfram.jlink.Expr. struct)
						(list? struct) (com.wolfram.jlink.Expr. (createExprSub (first struct)) (into-array com.wolfram.jlink.Expr (map createExprSub (rest struct))))
						(vector? struct) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"List\") (into-array com.wolfram.jlink.Expr (map createExprSub struct)))
						(map? struct) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"HashMap\") (into-array com.wolfram.jlink.Expr (map createExprSub struct)))
						(set? struct) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"HashSet\") (into-array com.wolfram.jlink.Expr (map createExprSub struct)))
						(seq? struct) (com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"List\") (into-array com.wolfram.jlink.Expr (map createExprSub struct)))
						true (let [s (gensym)] (set! java-object-map (assoc java-object-map s struct)) (createExprSub s))
					)	
		)"
]


load["(ns user)(use '[clojure.contrib.string :only [replace-str]]) 
(defn createExpr [struct] 
	(binding [java-object-map {}] 
		(let [resultexpr (createExprSub struct)] (object-array [(createExprSub (map first java-object-map)) (object-array (map last java-object-map)) resultexpr]) )
	) 	
)"
]


load["(ns user) 
(defn evalm [expr] 
	(binding [*ns* (create-ns 'user)] 
		(let [res (eval expr)]
			(if (ratio? res) 
					(com.wolfram.jlink.Expr. (com.wolfram.jlink.Expr.  4 \"Rational\") (into-array com.wolfram.jlink.Expr (map createExprSub [(numerator res) (denominator res)])))
				res))))
"]


ToClojureExpression[x_]:=ReturnAsJavaObject[(RT`var["user","to-s-expression"])@invoke[MakeJavaExpr@(x/.y_Symbol/;JavaObjectQ[y]:>\[FilledVerySmallSquare][jlink\[Dash]object\[Dash]handler,getObject[SymbolName[y]]] /. Times[a_,Power[b_,-1]]:>Division[a,b])]]


ClojureObjectEvaluate[x_]/;JavaObjectQ[x]:=With[{res=(RT`var["user","evalm"])@invoke[x]},res]


FromClojureExpression[x_]/;Not[JavaObjectQ[x]]:=x


FromClojureExpression[x_]:=With[{res=(RT`var["user","createExpr"])@invoke[x]},Last[res]/. Rule@@@Transpose[{res[[1]],res[[2]]}]]


ClojureEvaluate[x_]:=FromClojureExpression[ClojureObjectEvaluate[ToClojureExpression[x]]]



